CZECH TECHNICAL
UNIVERSITY
IN PRAGUE

F3

Faculty of Electrical Engineering
Department of Cybernetics

Semestral project

Multiagent planning system
demonstrator
Tůma Ondřej

Prosinec 2021
Supervisor: RNDr. Miroslav Kulich, Ph.D.

In collaboration with SafeLog, the laboratory demonstrator TurtleBot was created
for robot fleet trajectory planning in automated warehouses. The goal of this semestral
project is to analyze this framework and improve upon its codebase.

Acknowledgement / Declaration
I would really like to thank my supervisor RNDr. Miroslav Kulich, Ph.D.for
great mentoring and guidance and providing great advice when it was needed.
I would also like to thank to Ing. Tomáš
Rybeckýfor providing the base software
solution and for introducing me to the
problem domain. Finally, I would like to
acknowledge the co-authors of the original Fleet Management System and its
components, mainly Ing. Lukáš Bertl
and Ing. Jakub Hvězda Ph.D..

I declare that the presented work
was developed independently and that
I have listed all sources of information
used within it in accordance with the
methodical instructions for observing
the ethical principles in the preparation
of university theses.
Prague, date 18. May 2020

............................
signature

v

Abstrakt / Abstract
This work is analyzing and improving
upon the multiagent planning system
demonstrator currently used at the
Department of Cybernetics. The main
objective is to improve existing funccionality, add new features and enable
the usage of mapf-IR1 format. It will
greatly improve developer experience
for other students working and running
simulations developing alhorithms for
the mapf-IR2 solver.

vi

/ Contents
1 Introduction . . . . . . . . . . . . . . . . . . . . . . . .1

1.1 Original assignment . . . . . . . . . . . . . .1
1.2 Demonstrator current state
analysis . . . . . . . . . . . . . . . . . . . . . . . . . . .1
1.3 End goal . . . . . . . . . . . . . . . . . . . . . . . . . .2
2 A look at mapf-IR . . . . . . . . . . . . . . . . . . .3
2.1 Introduction . . . . . . . . . . . . . . . . . . . . . .3
2.2 The solver . . . . . . . . . . . . . . . . . . . . . . . .3
2.2.1 Input format . . . . . . . . . . . . . . .3
2.2.2 Output format . . . . . . . . . . . . .4
2.2.3 General format expectations . . . . . . . . . . . . . . . . . . . . . .4
2.3 The visualizer . . . . . . . . . . . . . . . . . . . .4
3 Implementation decisions . . . . . . . . .6
3.1 Current implementation . . . . . . . . .6
3.2 GUI library considerations . . . . . .6
3.3 GUI implementation considerations . . . . . . . . . . . . . . . . . . . . . . . . . . .7
4 Implementation . . . . . . . . . . . . . . . . . . . .8
4.1 Application architecture . . . . . . . . .8
4.2 GUI application . . . . . . . . . . . . . . . . . .9
References . . . . . . . . . . . . . . . . . . . . . . . . 11

vii

/ Figures
mapf-IR input format . . . . . . . . . . . .3
mapf-IR output format . . . . . . . . . .4
mapf-IR GUI . . . . . . . . . . . . . . . . . . . . .5
Communication UML . . . . . . . . . . . .8
Communication sequence diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9
4.3. GUI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.1.
2.2.
2.3.
4.1.
4.2.

viii

1

Chapter
Introduction
In this chapter, I will be describing the original assignment, the benefits of this project
and the current state of the work I will be basing this project upon.

1.1

Original assignment

In collaboration with SafeLog, the laboratory demonstrator TurtleBot was created for
robot fleet trajectory planning in automated warehouses. The goal of this semestral
project is to analyze this framework and improve upon its codebase. The tasks are as
follows:
1. Analyze multi-agent demonstrator and simulator mapf-IR1 and its current state of
development
2. Edit the simulator to serve as basic user interface for demonstrator (GUI)
3. Display robot positions received from the Vicon system
4. Integrate components for planning and generating plans into the system.

1.2

Demonstrator current state analysis

Currently, there exists old version2 of this project, that enables only basic functionality
for the simulations. This mainly includes:
1. Loading generated simulation data (in old format3 )
2. Run against physical robots in a lab with commands in a predefined order
It does the basics necessary to run the simulation. But it does not enable the user to
adjust or view the result. The old version4 receives feedback from robots after command
execution. It has no continuous data about the robots real-world positions. If collision
happens between two robots, the old version5 has no way of detecting and adjusting
the robots paths.
Current proprietary format is not compatible with mapf-IR6 input nor output format,
which makes the software at its current state useless for students developing algorithms
for the mentioned solver. And great amount of effort is required for students to run a
simulation using this software, if they happened to be working with compatible format.
1
2
3
4
5
6

https://github.com/Kei18/mapf-IR
https://gitlab.ciirc.cvut.cz/tumaond2/sipp/-/tree/b1d95a6eb73ac18e0c2bed042f463db15228e8ca
https://gitlab.ciirc.cvut.cz/tumaond2/sipp/-/tree/b1d95a6eb73ac18e0c2bed042f463db15228e8ca
https://gitlab.ciirc.cvut.cz/tumaond2/sipp/-/tree/b1d95a6eb73ac18e0c2bed042f463db15228e8ca
https://gitlab.ciirc.cvut.cz/tumaond2/sipp/-/tree/b1d95a6eb73ac18e0c2bed042f463db15228e8ca
https://github.com/Kei18/mapf-IR

1

1. Introduction

1.3

.........................................

End goal

The goal is to create version of the demonstrator that would improve developer experience for developers working on algorithmic solution compating with mapf-IR1 format,
and enable the possibility of presenting it to external visitors for representational purposes (ie. possible applicants).
Therefore the department will benefit internally from the increased productivity, and
lesser time spent on demonstration setup, and externally when presenting to possible
applicants. It should include the following features:
1. Purely virtual run
2. GUI with information about current run and ability to modify the run, such as
disabling individual agents, recalculating their paths if necessary and visualizing
additional relevant information.
3. Standardize input and output formats with mapf-IR2

1
2

https://github.com/Kei18/mapf-IR
https://github.com/Kei18/mapf-IR

2

2

Chapter
A look at mapf-IR
In this chapter I will take a detailed look at the inner workings of mapf-IR1 project.
mapf-IR2 is „A simulator and visualizer of Multi-Agent Path Finding (MAPF), used
in a paper Iterative Refinement for Real-Time Multi-Robot Path Planning (to
appear at IROS-21). It is written in C++(17) with CMake ( v3.16) build. The repository uses Google Test and the original library for 2D pathfinding as git submodules.
The visualizer uses openFrameworks and works only on macOS. “[1]

2.1

Introduction

mapf-IR3 consists of 2 parts. A solver and a visualizer. The solver is standalone
Cmake4 application and the visualizer is using openFrameworks as in our case. This
split is necessary as described in 3.2.

2.2
2.2.1

The solver
Input format

Figure 2.1. mapf-IR input format

The input format is as illustrated on 2.1 starting by name of map file on the first
line, followed by number of agents on the second, followed by the seed of the problem,
followed by two time configuration options. The next „number of agents“ lines are in
the format sX sY gX gY where sX and sY are the x and y coordinates of the starting
point, respectively, and gX, gY are the x and y coordinates of the goal, respectively.
1
2
3
4

https://github.com/Kei18/mapf-IR
https://github.com/Kei18/mapf-IR
https://github.com/Kei18/mapf-IR
https://cmake.org/

3

2. A look at mapf-IR

.......................................

Figure 2.2. mapf-IR output format

2.2.2

Output format

The output format is as illustrated on 2.2 with the important information being
number of agents on row 2, followed by starts coordinates on row 13 in format (x1,
y1), (x2, y2)... (x[number of agents], y300[number of agents]), where x and y are
the respective coordinates for each agent identified by the index of its coordinates
on the row. Followed by goals in the same format. Following are [makespan] lines
each representing single discrete timestep in the simulation, where each line has the
coordinates of each agent in the above mentioned format.

2.2.3

General format expectations

All positional data is assuming grid representation of the simulated map. The representation of the data expects the coordinate (0, 0) to be the top-left corner of the
simulation grid, while (xm - 1, ym - 1) is expected to be the bottom-right corner od
the grid, where xm, ym is the number of columns and rows in the simulation grid,
respectively.

2.3

The visualizer

The visualizer uses input file conforming to the format described in 2.2.2 to visualize
the run of generated simulation. It lets the user change the simulations speed and
move through discrete time steps. Other features include selecting only single agent to
display, stopping agent during simulation and visual features such as hiding/showing
of lines to goals.

4

........................................

Figure 2.3. mapf-IR GUI [2]

5

2.3 The visualizer

3

Chapter
Implementation decisions
In this chapter, I will briefly describe the implementation requirements provided and
decisions that were necessary before the actual implementation

3.1

Current implementation

The old version1 is using Cmake2 build system. It provides great benefits compared to
Makefile3 . Mainly portability across multiple build systems. The primary decision was
that we were to keep this build system for the server part of the application. This will
be important later when choosing gui in the section 3.2

3.2

GUI library considerations

The primary candidate for GUI library was openFrameworks4 . It provides extensive
amount of addons ranging greatly in functionality, with the pros being mainly:
1. Event loop synchronized with framerate
2. Interacting with the canvas using framework apis
3. Rich set of GUI widgets (buttons, text fields, etc.)
with the only downside being it’s dependence on Makefile5 . Therefore we are not
able to use the official version with our build system.
The developers are rather defensive about migrating build systems. The recommended way of building openFrameworks6 app is to clone the official repository, create
app using their template, and extend the makefiles provided by the original repository.
In order to be able to use this project with Cmake7 , it would be necessary to create
header map for each component of the framework.
There appear to be a few attempts to do this. Unfortunately, the wast majority of
them is out of date and unusable without heavy modifications.
The first one being ofxCMake8 . Its attempt is to provide the package as openFrameworks9 addon. Unfortunately, the latest version is from Aug 13, 2017, and there seems
to be no active development keeping it in sync.
1
2
3
4
5
6
7
8
9

https://gitlab.ciirc.cvut.cz/tumaond2/sipp/-/tree/b1d95a6eb73ac18e0c2bed042f463db15228e8ca
https://cmake.org/
https://www.gnu.org/software/make/
https://openframeworks.cc/
https://www.gnu.org/software/make/
https://openframeworks.cc/
https://cmake.org/
https://github.com/BildPeter/ofxCMake
https://openframeworks.cc/

6

..............................

3.3 GUI implementation considerations

Another one being ofnode1 , taking different approach. It has its own fork of openFrameworks2 repository, with mappings for Cmake3 . The latest version is from on Nov
7, 2018. I ran into several issues with system libraries with this version and was not
able to compile even the bare repository. It was then decided, that it would be most
beneficial to split the GUI into separate application using the Makefile4 .

3.3

GUI implementation considerations

First aspect was speed. The simulation might run hundreds of robots, depending on
the simulation. So on each robot move, it is necessary to send the minimal amount of
information required in order to keep the latency to a minimum. It was the decided,
that the plan will be synchronized between both applications on simulation start or
plan change. Any messages regarding the robot positions will be strictly referring
to the synchronized plan. Second aspect was ease-of-development. It is necessary to
create enough abstraction for the developer not to have to worry about the network.
A set of abstraction allowing to share messages and state in asynchronous manner will
be necessary. Ideally, the developer should not care whether the apps are running in
different threads or processes, the api should remain the same.

1
2
3
4

https://github.com/ofnode/of
https://openframeworks.cc/
https://cmake.org/
https://www.gnu.org/software/make/

7

4

Chapter
Implementation
In this chapter I will describe my implementation and the particular solutions used to
comply with decisions made in chapter 3.

4.1

Application architecture

The application is split between server part and frontend part. Communicating through
abstract interface built upon nanomsg1 .
Both parts of application have shared utils classes. The main classes used for communication are Messenger (asynchronous handler for inbound/outbound messages) and
Message (serializable container), providing easy-to-use interface and abstracting the
network layer away from the programmer. The basic hierarchy of used communication
classes is illustrated below.

Figure 4.1. Communication UML

1

https://nanomsg.org/

8

.......................................

4.2 GUI application

Server and Frontend each have its own instance of Messenger associated with given
Message type, communicating through api defined by given messenger. In the case of
SynchronizedStateMessenger, the only the latest version of the synchronized state is
publicly available to the user.
The asynchronous nature of the communication can be seen on the sequence diagram
below.

Figure 4.2. Communication sequence diagram

The asynchronous handlers allow both applications to run in the main thread performing latency-sensitive tasks.

4.2

GUI application

The GUI is implemented using openFrameworks1 . The GUI runs a single thread for
main logic and event handling, one for the GUI application, and one per each messenger,
allowing uninterrupted handling of all events that might arise and providing smooth
rendering for the application.

1

https://openframeworks.cc/

9

4. Implementation

........................................

Figure 4.3. GUI

The gui, as visualized on 4.3, displays robot positions at provided discrete time
steps, allowing the user to browse all time steps and show available information about
them. It also provides the user with the ability to disable individual agents for given
simulation run, and to completely start and stop the simulation run.

10

References
[1] Keisuke Okumura. Kei18/MAPF-IR: Iterative refinement for real-time multi-robot
path planning (IROS-21).
https://github.com/Kei18/mapf-IR.
[2] Keisuke Okumura. Kei18/MAPF-IR: Iterative refinement for real-time multi-robot
path planning (IROS-21).
https://github.com/Kei18/mapf-IR/blob/public/material/arena_100agents.gif.

11

