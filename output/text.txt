CZECH TECHNICAL
UNIVERSITY
IN PRAGUE

F3

Faculty of Electrical Engineering
Department of Cybernetics

Semestral project

Multiagent planning system
demonstrator
Tůma Ondřej

Prosinec 2021
Supervisor: RNDr. Miroslav Kulich, Ph.D.

In collaboration with SafeLog, the laboratory demonstrator TurtleBot was created
for robot fleet trajectory planning in automated warehouses. The goal of this semestral
project is to analyze this framework and improve upon its codebase.

Acknowledgement / Declaration
I would really like to thank my supervisor RNDr. Miroslav Kulich, Ph.D.for
great mentoring and guidance and providing great advice when it was needed.
I would also like to thank to Ing. Tomáš
Rybeckýfor providing the base software
solution and for introducing me to the
problem domain. Finally, I would like to
acknowledge the co-authors of the original Fleet Management System and its
components, mainly Ing. Lukáš Bertl
and Ing. Jakub Hvězda Ph.D..

I declare that the presented work
was developed independently and that
I have listed all sources of information
used within it in accordance with the
methodical instructions for observing
the ethical principles in the preparation
of university theses.
Prague, date 18. May 2020

............................
signature

v

Abstrakt / Abstract
This work is analyzing and improving
upon the multiagent planning system
demonstrator currently used at the
Department of Cybernetics. The main
objective is to improve existing funccionality, add new features and enable
the usage of mapf-IR1 format. It will
greatly improve developer experience
for other students working and running
simulations developing alhorithms for
the mapf-IR2 solver.

vi

/ Contents
1 Introduction . . . . . . . . . . . . . . . . . . . . . . . .1

1.1 Original assignment . . . . . . . . . . . . . .1
1.2 Demonstrator current state
analysis . . . . . . . . . . . . . . . . . . . . . . . . . . .1
1.3 End goal . . . . . . . . . . . . . . . . . . . . . . . . . .2
2 Implementation decisions . . . . . . . . .3
2.1 Current implementation . . . . . . . . .3
2.2 GUI library considerations . . . . . .3
2.3 GUI implementation considerations . . . . . . . . . . . . . . . . . . . . . . . . . . .4
3 Implementation . . . . . . . . . . . . . . . . . . . .5
3.1 Application architecture . . . . . . . . .5
3.2 GUI application . . . . . . . . . . . . . . . . . .6
References . . . . . . . . . . . . . . . . . . . . . . . . . .7

vii

/ Figures
3.1. Communication UML . . . . . . . . . . . .5
3.2. Communication sequence di-

agram . . . . . . . . . . . . . . . . . . . . . . . . . . . . .6

viii

1

Chapter
Introduction
In this chapter, I will be describing the original assignment, the benefits of this project
and the current state of the work I will be basing this project upon.

1.1

Original assignment

In collaboration with SafeLog, the laboratory demonstrator TurtleBot was created for
robot fleet trajectory planning in automated warehouses. The goal of this semestral
project is to analyze this framework and improve upon its codebase. The tasks are as
follows:
1. Analyze multi-agent demonstrator and simulator mapf-IR1 and its current state of
development
2. Edit the simulator to serve as basic user interface for demonstrator (GUI)
3. Display robot positions received from the Vicon system
4. Integrate components for planning and generating plans into the system.

1.2

Demonstrator current state analysis

Currently, there exists old version2 of this project, that enables only basic functionality
for the simulations. This mainly includes:
1. Loading generated simulation data (in old format3 )
2. Run against physical robots in a lab with commands in a predefined order
It does the basics necessary to run the simulation. But it does not enable the user to
adjust or view the result. The old version4 receives feedback from robots after command
execution. It has no continuous data about the robots real-world positions. If collision
happens between two robots, the old version5 has no way of detecting and adjusting
the robots paths.
Current proprietary format is not compatible with mapf-IR6 input nor output format,
which makes the software at its current state useless for students developing algorithms
for the mentioned solver. And great amount of effort is required for students to run a
simulation using this software, if they happened to be working with compatible format.
1
2
3
4
5
6

https://nanomsg.org/
https://github.com/Kei18/mapf-IR
https://nanomsg.org/
https://github.com/Kei18/mapf-IR
https://github.com/Kei18/mapf-IR
https://nanomsg.org/

1

1. Introduction

1.3

.........................................

End goal

The goal is to create version of the demonstrator that would improve developer experience for developers working on algorithmic solution for mapf-IR1 , and enable the
possibility of presenting it to external visitors for representational purposes (ie. possible
applicants).
Therefore the department will benefit internally from the increased productivity, and
lesser time spent on demonstration setup, and externally when presenting to possible
applicants. It should include the following features:
1. Purely virtual run
2. GUI with information about current run
3. Standardize input and output formats with mapf-IR2

1
2

https://nanomsg.org/
https://nanomsg.org/

2

2

Chapter
Implementation decisions
In this chapter, I will briefly describe the implementation requirements provided and
decisions that were necessary before the actual implementation

2.1

Current implementation

The old version1 is using Cmake2 build system. It provides great benefits compared to
Makefile3 . Mainly portability across multiple build systems. The primary decision was
that we were to keep this build system for the server part of the application. This will
be important later when choosing gui in the section 2.2

2.2

GUI library considerations

The primary candidate for GUI library was openFrameworks4 . It provides extensive
amount of addons ranging greatly in functionality, with the pros being mainly:
1. Event loop synchronized with framerate
2. Interacting with the canvas using framework apis
3. Rich set of GUI widgets (buttons, text fields, etc.)
with the only downside being it’s dependence on Makefile5 . Therefore we are not
able to use the official version with our build system.
The developers are rather defensive about migrating build systems. The recommended way of building openFrameworks6 app is to clone the official repository, create
app using their template, and extend the makefiles provided by the original repository.
In order to be able to use this project with Cmake7 , it would be necessary to create
header map for each component of the framework.
There appear to be a few attempts to do this. Unfortunately, the wast majority of
them is out of date and unusable without heavy modifications.
The first one being ofxCMake. Its attempt is to provide the package as openFrameworks8 addon. Unfortunately, the latest version is from Aug 13, 2017, and there seems
to be no active development keeping it in sync.
1
2
3
4
5
6
7
8

https://github.com/Kei18/mapf-IR
https://nanomsg.org/
https://nanomsg.org/
https://github.com/Kei18/mapf-IR
https://nanomsg.org/
https://github.com/Kei18/mapf-IR
https://nanomsg.org/
https://github.com/Kei18/mapf-IR

3

2. Implementation decisions

...................................

Another one being ofnode, taking different approach. It has its own fork of openFrameworks1 repository, with mappings for Cmake2 . The latest version is from on Nov
7, 2018. I ran into several issues with system libraries with this version and was not
able to compile even the bare repository. It was then decided, that it would be most
beneficial to split the GUI into separate application using the Makefile3 .

2.3

GUI implementation considerations

First aspect was speed. The simulation might run hundreds of robots, depending on
the simulation. So on each robot move, it is necessary to send the minimal amount of
information required in order to keep the latency to a minimum. It was the decided,
that the plan will be synchronized between both applications on simulation start or
plan change. Any messages regarding the robot positions will be strictly referring
to the synchronized plan. Second aspect was ease-of-development. It is necessary to
create enough abstraction for the developer not to have to worry about the network.
A set of abstraction allowing to share messages and state in asynchronous manner will
be necessary. Ideally, the developer should not care whether the apps are running in
different threads or processes, the api should remain the same.

1
2
3

https://github.com/Kei18/mapf-IR
https://nanomsg.org/
https://nanomsg.org/

4

3

Chapter
Implementation
In this chapter I will describe my implementation and the particular solutions used to
comply with decisions made in chapter 2.

3.1

Application architecture

The application is split between server part and frontend part. Communicating through
abstract interface built upon nanomsg1 .
Both parts of application have shared utils classes. The main classes used for communication are Messenger (asynchronous handler for inbound/outbound messages) and
Message (serializable container), providing easy-to-use interface and abstracting the
network layer away from the programmer. The basic hierarchy of used communication
classes is below.

Figure 3.1. Communication UML

1

https://nanomsg.org/

5

3. Implementation

........................................

Server and Frontend each have its own instance of Messenger associated with given
Message type, communicating through api defined by given messenger. In the case of
SynchronizedStateMessenger, the only the latest version of the synchronized state is
publicly available to the user.
The asynchronous nature of the communication can be seen on the sequence diagram
below.

Figure 3.2. Communication sequence diagram

The asynchronous handlers allow both applications to run in the main thread performing latency-sensitive tasks.

3.2

GUI application

The GUI is implemented using openFrameworks1 . The GUI runs a single thread for
main logic and event handling, one for the GUI application, and one per each messenger,
allowing uninterrupted handling of all events that might arise and providing smooth
rendering for [1] the application.

1

https://github.com/Kei18/mapf-IR

6

References
[1] Tomáš Rybecký. Trajectory planning for a heterogeneous team in an automated
warehouse. 2020.
https: / / dspace . cvut . cz / bitstream / handle / 10467 / 88088 / F3-DP-2020-RybeckyTomas-thesis.pdf?sequence=-1&isAllowed=y.

7

