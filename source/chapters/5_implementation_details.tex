\chap Implementation
In this chapter I will describe my implementation and the particular solutions used to comply with decisions made in chapter ~\ref[chapter_implementation_decisions].

\sec Application architecture
The application is split between server, frontend and robot part.
The Server is central part of the project, communicating with the frontend and robots. Robots and Frontend communicate only with the server and are completely independent of each other.
\secc Communication
Communicating through an abstract interface built upon \nanomsg.

All parts of the application have shared utils classes. The main classes used for communication are Messenger\label[messenger]\wlabel{} (asynchronous handler for inbound/outbound messages) and Message (serializable container), providing an easy-to-use interface and abstracting the network layer away from the programmer. The basic hierarchy of used communication classes is illustrated below.
\communicationUml
\break
Server and Frontend each have its own instance of Messenger associated with given Message type, communicating through api defined by given messenger. In the case of SynchronizedStateMessenger, only the latest version of the synchronized state is publicly available to the user.

The asynchronous nature of the communication can be seen in the sequence diagram below.

\communicationSequence

The asynchronous handlers allow both applications to run in the main thread performing latency-sensitive tasks. The current implementation uses thread per messenger, mainly to eliminate application-wide locking and shared state, but another more optimal approach could be single static event loop for all messengers. It would be more efficient, but could introduce hard to debug bugs where one Messenger instance could affect every other messenger. It was decided to go with the threaded implementation. But the Messenger architecture makes it possible to simple change the implementation if it proves to have additional benefits.

\sec Shared resources
Since one part of the application is built using \makefile, and the other part using \cmake, it made sharing code across parts of the application more difficult. The configuration of \of only allows one user defined include directory, so all the shared files have flat structure in the "{projectRoot}/FleetControl/modules/utils/Comm".
\sec TurtleBot build
TurtleBot software is build using CMake.
The sources for the TurtleBot are in the "/src" directory, where the actual code resides in the "/src/agv_package/TurtleBot/" directory.
\sec TurtleBot runtime
After TurtleBot is started, it listens for instructions from the server and broadcasts its perceived position.
At runtime, the TurtleBot uses the following ports.
\begitems \style x
    * single port defined in "/robot_definitions.txt" - server commands handling
    * 9980 - position feedback
\enditems
\sec Server
\secc Vicon
The laboratory is equipped with Vicon motion capture system, monitoring the area spanned by robots completely. The purpose of the system is to provide positions of defined known objects.\br
The system consists of a central server, and high refresh rate motion cameras emplaced on the ceiling of the laboratory around the monitored area. Additional tooling is used to transform the source data from the Vicon system into network stream that can be consumed by other applications running on the local network.\br
The actual usage in the server is then relatively straightforward. Each robot is assigned a name in the Vicon system, that is referenced in the file with robot definitions in th root of the project. Afterwards, when the Vicon system is running, we are able to transform the output data into continuous stream of data, send it over the network to the Server, filter out only wanted objects, and save current position provided by Vicon for each robot. The final position for each robot is periodically transferred to Frontend primarily to save network bandwidth. But given the high refresh rate of the positioning system, and the relatively low speed of physical robots, the updating frequency was set to 100ms without any noticeable delay in the user interface.
\sec Client build
\sec Client runtime
The GUI is implemented using {\of}. The GUI runs a single thread for main logic and event handling, one for the GUI application. Communication with server is directed through the Messenger abstraction, allowing uninterrupted handling of all events that might arise and providing smooth rendering for the application. 
\fleetControlGui
\break
The GUI, as visualized on ~\ref[fleet_control_user_interface], displays robot positions based on pro feedback from robots, or alternatively connection to the Vicon system, allowing the user to browse all time steps and show available information about them. It also provides the user with the ability to disable individual agents for a given simulation run and to completely start and stop the simulation run.
\fleetControlAdminPanel
Most of the setting can be changed on the admin panel on the left side of the application window.
\sec Environment setup
\sec Environment behavior
\br\br
\sec Robot synchronization strategies
\secc Disctinct time step
\secc ADG
\midinsert
\newcount\X
\X=1


\endinsert