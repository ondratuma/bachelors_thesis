\chap Implementation
In this chapter I will describe my implementation and the particular solutions used to comply with decisions made in chapter ~\ref[chapter_implementation_decisions].

\sec Application architecture
The application is split between server, frontend and robot part.
Communicating through an abstract interface built upon \nanomsg.

All parts of the application have shared utils classes. The main classes used for communication are Messenger (asynchronous handler for inbound/outbound messages) and Message (serializable container), providing an easy-to-use interface and abstracting the network layer away from the programmer. The basic hierarchy of used communication classes is illustrated below.
\communicationUml
\break
Server and Frontend each have its own instance of Messenger associated with given Message type, communicating through api defined by given messenger. In the case of SynchronizedStateMessenger, only the latest version of the synchronized state is publicly available to the user.

The asynchronous nature of the communication can be seen in the sequence diagram below.

\communicationSequence

The asynchronous handlers allow both applications to run in the main thread performing latency-sensitive tasks. The current implementation uses thread per messenger, mainly to eliminate application-wide locking and shared state, but another more optimal approach could be single static event loop for all messengers. It would be more efficient, but could introduce hard to debug bugs where one Messenger instance could affect every other messenger. It was decided to go with the threaded implementation. But the Messenger architecture makes it possible to simple change the implementation if it proves to have additional benefits.

\sec Shared resources
Since one part of the application is built using makefile, and the other part using CMake, it made sharing code across parts of the application more difficult. The configuration of openFrameworks only allows one user defined include directory, so all the shared files have flat structure in the "{projectRoot}/FleetControl/modules/utils/Comm".
\sec Communication schema
\sec TurtleBot build
TurtleBot software is build using CMake.
The sources for the rutlebot are in the "/src" directory, where the actual code resides in the "/src/agv_package/TurtleBot/" directory.
\sec TurtleBot runtime
After turtlebot is started, it listens for instructions from the server and broadcasts its perceived position.
At runtime, the TurtleBot uses the following ports.
\begitems \style x
    * single port defined in "/robot_definitions.txt" - server commands handling
    * 9980 - position feedback
\enditems
\sec Server build
\sec Server runtime
\sec Client build
\sec Client runtime
The GUI is implemented using {\of}. The GUI runs a single thread for main logic and event handling, one for the GUI application, and one per each messenger, allowing uninterrupted handling of all events that might arise and providing smooth rendering for the application. 
\fleetControlGui
\break
The GUI, as visualized on ~\ref[fleet_control_user_interface], displays robot positions at provided discrete time steps, allowing the user to browse all time steps and show available information about them. It also provides the user with the ability to disable individual agents for a given simulation run and to completely start and stop the simulation run.
\sec Environment setup
\sec Environment behavior
