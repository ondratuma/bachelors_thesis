\chap Implementation
In this chapter I will describe my implementation and the particular solutions used to comply with decisions made in chapter ~\ref[chapter_implementation_decisions].

\sec Application architecture
The application is split between server, frontend and robot part.
The Server is central part of the project, communicating with the frontend and robots. Robots and Frontend communicate only with the server and are completely independent of each other.
\secc Communication
Communicating through an abstract interface built upon \nanomsg.

All parts of the application have shared utils classes. The main classes used for communication are Messenger\label[messenger]\wlabel{} (asynchronous handler for inbound/outbound messages) and Message (serializable container), providing an easy-to-use interface and abstracting the network layer away from the programmer. The basic hierarchy of used communication classes is illustrated below.
\communicationUml
\break
Server and Frontend each have its own instance of Messenger associated with given Message type, communicating through api defined by given messenger. In the case of SynchronizedStateMessenger, only the latest version of the synchronized state is publicly available to the user.

The asynchronous nature of the communication can be seen in the sequence diagram below.

\communicationSequence

The asynchronous handlers allow both applications to run in the main thread performing latency-sensitive tasks. The current implementation uses thread per messenger, mainly to eliminate application-wide locking and shared state, but another more optimal approach could be single static event loop for all messengers. It would be more efficient, but could introduce hard to debug bugs where one Messenger instance could affect every other messenger. It was decided to go with the threaded implementation. But the Messenger architecture makes it possible to simple change the implementation if it proves to have additional benefits.

\sec Shared resources
Since one part of the application is built using \makefile, and the other part using \cmake, it made sharing code across parts of the application more difficult. The configuration of \of only allows one user defined include directory, so all the shared files have flat structure in the "{projectRoot}/FleetControl/modules/utils/Comm".
\sec TurtleBot build
TurtleBot software is build using CMake.
The sources for the TurtleBot are in the "/src" directory, where the actual code resides in the "/src/agv_package/TurtleBot/" directory.
\sec TurtleBot runtime
After TurtleBot is started, it listens for instructions from the server and broadcasts its perceived position.
At runtime, the TurtleBot uses the following ports.
\begitems \style x
    * single port defined in "/robot_definitions.txt" - server commands handling
    * 9980 - position feedback
\enditems
\sec Server
\secc Vicon
The laboratory is equipped with Vicon motion capture system, monitoring the area spanned by robots completely. The purpose of the system is to provide positions of defined known objects.\br
The system consists of a central server, and high refresh rate motion cameras emplaced on the ceiling of the laboratory around the monitored area. Additional tooling is used to transform the source data from the Vicon system into network stream that can be consumed by other applications running on the local network.\br
The actual usage in the server is then relatively straightforward. Each robot is assigned a name in the Vicon system, that is referenced in the file with robot definitions in th root of the project. Afterwards, when the Vicon system is running, we are able to transform the output data into continuous stream of data, send it over the network to the Server, filter out only wanted objects, and save current position provided by Vicon for each robot. The final position for each robot is periodically transferred to Frontend primarily to save network bandwidth. But given the high refresh rate of the positioning system, and the relatively low speed of physical robots, the updating frequency was set to 100ms without any noticeable delay in the user interface.
\sec Client build
\vfil \break
\sec Client runtime
The GUI is implemented using {\of}. The GUI runs a single thread for main logic and event handling, one for the GUI application. Communication with server is directed through the Messenger abstraction, allowing uninterrupted handling of all events that might arise and providing smooth rendering for the application. 
\fleetControlGui
\break
The GUI, as visualized on ~\ref[fleet_control_user_interface], displays robot positions based on pro feedback from robots, or alternatively connection to the Vicon system, allowing the user to browse all time steps and show available information about them. It also provides the user with the ability to disable individual agents for a given simulation run and to completely start and stop the simulation run.
\fleetControlAdminPanel
Most of the setting can be changed on the admin panel on the left side of the application window.
\sec Environment setup
\sec Environment behavior
\br\br
\sec Robot synchronization strategies
The solver solves the problem set in discreet time steps. The solution should guarantee that the simulation will be run without collisions. Howewer, that can be quite inefficient, as in the real world, the speeds of individual robots may differ from the expected ones, and making all robots wait for single slow robot may lead to a bottlenect on the whole system. It is therefore desirable to be able to break the disctinct step barrier. That may, however, break the consistency of the plan, and introduce potential collisions. Once we disable this implicit safeguard, it is necessary to introduce additional, possibly more efficient solution, that will prevent collisions and enable the simulation to run without inconsistencies.\br
By eliminating the implicit barrier, we are able to dynamically enable and disable multiple synchronization strategies, making the system more modular, and allowing demonstration and development of new algorithms without any modification to existing strategies. Each strategy should act independently on the state of other strategies. \br
Currently, reimplementation of the original implicit barrier and Action dependency graph strategy are available.
\secc Discreet time step
This synchronization strategy is reintroducing the constraints given by the solver output, keeping all robots in the same time step, until the last one finishes execution. The reintroduction of the implicit barrier as modular strategy makes it great for testing new planning algorithms, where the original solution of the solver can be inspected without real-world inconsistencies.
\vfil \break
\secc Action dependency graph
The second currently implemented approach is to construct action dependency graph of the nodes, and ensure the correct execution order for actions on given nodes. The algorithm was inspired by the {\uv{Persistent and Robust Execution of MAPF Schedules in Warehouses}\cite[adgPaper] paper. It greatly increases the efficiency, allowing robots to move, until they break the dependency graph. In the original paper, replanning algorithm is also introduced, but it was not implemented here for demonstration purposes, as changing the plan during execution would be quite contrary to the idea of the demonstrator, where we are demonstrating the execution plan. It might, however, be quite interesting demonstration on its own. \br
On the figures {~\ref[adg_step_1]}-{~\ref[adg_step_15]} you can see part of the execution using ADG. The figures are not spaced evenly relative to the simulation time, rather selected to represent significant events during the execution. \br
Before the {~\ref[adg_step_3]}, the execution is running normally. However, somewhere between {~\ref[adg_step_2]} and {~\ref[adg_step_3]}, the green robot has been delayed. In order to continue execution, the red robot has to wait. This is represented by having the currently waiting robot's grid block highlighted in red, as can be seen in {~\ref[adg_step_3]}.
The red robot continues to wait, until the next node in its desired path is free (from the ADG perspective). Meaning that every robot, who planned to travel through the node before this one already did so.
\midinsert
\line{\hsize=.3333333333\hsize \vtop{%
        \clabel[adg_step_1]{Krok 1}
        \picw=3.5cm \cinspic {../assets/images/new_ui_adg_1.png}
        \caption/f Krok 1
   \par}\vtop{%
        \clabel[adg_step_2]{Krok 2}
        \picw=3.5cm \cinspic {../assets/images/new_ui_adg_3.png}
        \caption/f Krok 2
   \par}\vtop{%
        \clabel[adg_step_3]{Krok 3}
        \picw=3.5cm \cinspic {../assets/images/new_ui_adg_4.png}
        \caption/f Krok 3
   \par}}
\endinsert
\midinsert
\line{\hsize=.3333333333\hsize \vtop{%
   \clabel[adg_step_4]{Krok 4}
   \picw=3.5cm \cinspic {../assets/images/new_ui_adg_5.png}
   \caption/f Krok 4
\par}\vtop{%
   \clabel[adg_step_5]{Krok 5}
   \picw=3.5cm \cinspic {../assets/images/new_ui_adg_6.png}
   \caption/f Krok 5
\par}\vtop{%
   \clabel[adg_step_6]{Krok 6}
   \picw=3.5cm \cinspic {../assets/images/new_ui_adg_7.png}
   \caption/f Krok 6
\par}}
\endinsert
\midinsert
\line{\hsize=.3333333333\hsize \vtop{%
   \clabel[adg_step_7]{Krok 7}
   \picw=3.5cm \cinspic {../assets/images/new_ui_adg_8.png}
   \caption/f Krok 7
\par}\vtop{%
   \clabel[adg_step_8]{Krok 8}
   \picw=3.5cm \cinspic {../assets/images/new_ui_adg_9.png}
   \caption/f Krok 8
\par}\vtop{%
   \clabel[adg_step_9]{Krok 9}
   \picw=3.5cm \cinspic {../assets/images/new_ui_adg_10.png}
   \caption/f Krok 9
\par}}
\endinsert
\midinsert
\line{\hsize=.3333333333\hsize \vtop{%
   \clabel[adg_step_10]{Krok 12}
   \picw=3.5cm \cinspic {../assets/images/new_ui_adg_8.png}
   \caption/f Krok 10
\par}\vtop{%
   \clabel[adg_step_11]{Krok 11}
   \picw=3.5cm \cinspic {../assets/images/new_ui_adg_9.png}
   \caption/f Krok 11
\par}\vtop{%
   \clabel[adg_step_12]{Krok 12}
   \picw=3.5cm \cinspic {../assets/images/new_ui_adg_10.png}
   \caption/f Krok 12
\par}}
\endinsert
\midinsert
\line{\hsize=.3333333333\hsize \vtop{%
   \clabel[adg_step_13]{Krok 13}
   \picw=3.5cm \cinspic {../assets/images/new_ui_adg_8.png}
   \caption/f Krok 13
\par}\vtop{%
   \clabel[adg_step_14]{Krok 14}
   \picw=3.5cm \cinspic {../assets/images/new_ui_adg_9.png}
   \caption/f Krok 15
\par}\vtop{%
   \clabel[adg_step_15]{Krok 15}
   \picw=3.5cm \cinspic {../assets/images/new_ui_adg_10.png}
   \caption/f Krok 16
\par}}
\endinsert