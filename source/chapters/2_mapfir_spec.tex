\chap Analysis of the mapf-IR project
In this chapter, I will take a detailed look at the inner workings of the {\mapfIR} project. This chapter also aims to point out the differences in formats and inner workings that might play an important role during implementation.

\sec Introduction
{\mapfIR} is {\uv{A simulator and visualizer of Multi-Agent Path Finding (MAPF), used in a paper "Iterative Refinement for Real-Time Multi-Robot Path Planning" (to appear at IROS-21). It is written in C++(17) with CMake (â‰¥v3.16) build. The repository uses Google Test and the original library for 2D pathfinding as git submodules. The visualizer uses openFrameworks and works only on macOS.
    }\cite[MAPFIR:REPO_DESCRIPTION]
}.\br\br
The project consists of 2 parts.
\begmulti 2
{\bf The solver} is a standalone {\cmake} application. It generates a simple CLI binary executable that allows the user to generate an execution plan based on a problem definition. It supports multiple planning algorithms that can be switched using the command-line arguments. \vfil\break 
{\bf The visualizer} is based on {\of} and is built using {\makefile}. It is used to visualize the output of the solver once it has been generated. The user is able to change the visualization speed and highlight particular robots.\break 
\endmulti
This split is necessary, as described in {~\ref[choosing_gui]}. The general workflow is to:
\begitems \style n
    * Run the solver on a problem set as described in {~\ref[mapfir_solver_input]}, creating output in the format described in {~\ref[mapfir_solver_output_format]} 
    * Visualize the solution using the visualizer {~\ref[mapfir_visualizer]}
\enditems
Although the project description says it does support only macOS, there seems to be no problem compiling and running under Linux. This appears to be coming from the lack of documentation and documentation in an outdated state whenever it actually exists. This seems to be a common pattern for the {\of} applications and the project components as well.

\label[mapfir_solver]
\sec The solver
This section aims to describe the solver and analyze the input and output formats used by the solver. This formatting will be important when migrating our application from the \oldFormat.

The solver is used to generate an execution plan in discreet time steps. It focuses solely on the generation of static plans. It currently supports the following algorithms.
{\uv {HCA* and WHCA* [1], PIBT [2], CBS [3], ICBS [4], ECBS [5], Revisit Prioritized Planning [6], Push and Swap [7], winPIBT [8], PIBT+, and IR (Iterative Refinement).
}}\cite[MAPFIR:REPO_DESCRIPTION]

\label[mapfir_solver_input]
\secc{Input format}
The input is description of the path-finding problem that is given to the solver, which in turn tries to create a solution for given problem set.
\begtt
map_file=arena.map
agents=300
seed=0
random_problem=0
max_timestep=500
max_comp_time=30000
36,33,5,23
3,17,23,33
30,15,9,27
19,35,42,30
8,21,2,18
\endtt
The input format is illustrated above. The file starts with the name of a map file on the first line, continuing with the number of agents on the second line, followed by the seed of the problem and by two time configuration options.
The next \uv{number of agents} lines are in the format $s_x$ $s_y$ $g_x$ $g_y$ where $s_x$ and $s_y$ are the x and y coordinates of the starting point, respectively, and $g_x$, $g_y$ are the x and y coordinates of the goal, respectively. 

\label[mapfir_solver_output_format]
\secc{Output format}
The output file is solution to a given path-finding problem on a given map, with additional metadata included.
\begtt
instance=instances/arena_300agents_1.txt
agents=300
map_file=arena.map
solver=IR_HYBRID
solved=1
soc=12085
lb_soc=9722
makespan=80
lb_makespan=80
comp_time=414
iter=0,comp_time=20,soc=13284,makespan=13284
starts=(36,33),(3,17),(30,15),(19,35),...
goals=(5,23),(23,33),(9,27),(42,30),...
solution=
0:(36,33),(3,17),(30,15),(19,35),...
...
80:(5,23),(23,33),(9,27),(42,30),...
\endtt
The output format is as illustrated above, with the important information being the number of agents on row 2, followed by starts coordinates on row 13 in the format ($x_1$, $y_1$), ($x_2$, $y_2$)... ($x_m$, $y_m$),  where x and y are the respective coordinates for each agent identified by the index of its coordinates on the row, and m is the number of agents. Followed by goals in the same format. Following are {\uv {makespan}} lines, each representing a single discrete timestep in the simulation, where each line has the coordinates of each agent in the above-mentioned format.

\label[mapfir_map_format]
\secc{Map format}
Below is an example map file. This file format is used both by the solver and visualizer to represent the environment. On the first line is the map type, represented by a string. Following are two lines representing the dimensions.
On the $5^{th}$ line starts the actual map represented by m rows and n columns, where m and n are the height and width of the grid dimensions, respectively. Each grid tile is represented by a single ASCII character. Currently, only two characters are used. 
\begitems \style x
    * "." - Representing blank space
    * "T" - Representing an obstacle
\enditems
\begtt
type octile
height 14
width 13
map
T....TTT....T
T...........T
.............
.............
.............
.............
.............
......T......
.............
.............
.............
.............
....T.T.T....
T..TTTTT....T
\endtt

\label[mapfir_coordinate_system]
\secc{Coordinate system convention}
All positional data assumes a grid representation of the simulated map. The representation of the data expects the coordinate (0, 0) to be the top-left corner of the simulation grid, while ($x_m - 1$, $y_m - 1$) is expected to be the bottom-right corner of the grid, where $x_m$, $y_m$ is the number of columns and rows in the simulation grid, respectively. This perception comes from the fact that in GUI applications, the coordinate system grows from the upper left corner.

\label[mapfir_visualizer]
\sec The visualizer
The visualizer uses an input file conforming to the format described in {~\ref[mapfir_solver_output_format]} and {~\ref[mapfir_map_format]} to visualize the run of the generated simulation. It lets the user change the simulation speed and move through discrete time steps. Other features include selecting only a single agent to display, stopping the agent during the simulation, and visual features such as hiding/showing the lines to goals.
\mapfirGui 

\sec Benefits 
The benefits of the format used by mapfIR are mainly
\begitems \style x
    * Human readability
    * Simple parsing
    * Ability to use community solvers
\enditems
Additionally, I believe that switching to a standardized IO format will enable more students to use the demonstrator, and eventually introduce new use-cases that were not possible before due to the inaccessibility of the demonstrator. The ability to execute the generated execution plan on real robots might greatly increase the attractiveness of the field for students developing algorithms for pathfinding.