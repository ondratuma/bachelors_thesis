\chap Analysis of the mapf-IR project
In this chapter I will take a detailed look at the inner workings of {\mapfIR} project. The purpose of this chapter is to also point out differences in formats and inner workings that might play important role during implementation.

\sec Introduction
{\mapfIR} is {\uv{A simulator and visualizer of Multi-Agent Path Finding (MAPF), used in a paper "Iterative Refinement for Real-Time Multi-Robot Path Planning" (to appear at IROS-21). It is written in C++(17) with CMake (â‰¥v3.16) build. The repository uses Google Test and the original library for 2D pathfinding as git submodules. The visualizer uses openFrameworks and works only on macOS.
    }\cite[MAPFIR:REPO_DESCRIPTION]
}.\br\br
{\mapfIR} consists of 2 parts.
\begmulti 2
{\bf The solver} is a standalone {\cmake} application. It generates a simple cli binary executable, that allows the user to generate execution plan based on problem definition. It supports multiple planning algorithms, that can be switched using command line arguments. \vfil\break 
{\bf The visualizer} is based on {\of} and is built using {\makefile}. It is used to visualize the output of the solver once it has been generated. The user is able to change the visualization speed, and highlight particular robots.\break 
\endmulti
This split is necessary as described in {~\ref[choosing_gui]}. The general workflow is to:
\begitems \style n
    * Run the solver on a problem set as described in {~\ref[mapfir_solver_input]}, creating output in format described in {~\ref[mapfir_solver_output_format]} 
    * Visualize the solution using the visualizer {~\ref[mapfir_visualizer]}
\enditems
Although the project description says it does support only macOs, there seems to be no problem compiling and running under linux. This seems to be coming from the lack of documentation, and documentation in outdated state whenever it actually exists. This seems to be a common pattern for the {\of} applications and the project components as well.

\label[mapfir_solver]
\sec The solver
This section aims to describe the solver and analyze the input and output formats used by the solver. This formatting will be important when migrating our application from \oldFormat.
\secc Solver description
The solver is used to generate execution plan in discreet time steps. It is focusing solely on the generation of static plans. It currently supports the following algorithms.
{\uv {HCA* and WHCA* [1], PIBT [2], CBS [3], ICBS [4], ECBS [5], Revisit Prioritized Planning [6], Push and Swap [7], winPIBT [8], PIBT+, and IR (Iterative Refinement).
}}\cite[MAPFIR:REPO_DESCRIPTION]
\label[mapfir_solver_input]
\secc{Input format}
The input is description of the path-finding problem that is given to the solver, which in turn tries to create a solution for given problem set.
\begtt
map_file=arena.map
agents=300
seed=0
random_problem=0
max_timestep=500
max_comp_time=30000
36,33,5,23
3,17,23,33
30,15,9,27
19,35,42,30
8,21,2,18
\endtt
The input format is as illustrated on above starting by the name of a map file on the first line, followed by the number of agents on the second, followed by the seed of the problem, followed by two time configuration options.
The next \uv{number of agents} lines are in the format sX sY gX gY where sX and sY are the x and y coordinates of the starting point, respectively, and gX, gY are the x and y coordinates of the goal, respectively. 

\label[mapfir_solver_output_format]
\secc{Output format}
The output file is solution to a given path-finding problem on a given map, with additional metadata included.
\begtt
instance=instances/arena_300agents_1.txt
agents=300
map_file=arena.map
solver=IR_HYBRID
solved=1
soc=12085
lb_soc=9722
makespan=80
lb_makespan=80
comp_time=414
iter=0,comp_time=20,soc=13284,makespan=13284
starts=(36,33),(3,17),(30,15),(19,35),...
goals=(5,23),(23,33),(9,27),(42,30),...
solution=
0:(36,33),(3,17),(30,15),(19,35),...
...
80:(5,23),(23,33),(9,27),(42,30),...
\endtt
The output format is as illustrated above with the important information being the number of agents on row 2, followed by starts coordinates on row 13 in format ($x_1$, $y_1$), ($x_2$, $y_2$)... ($x_m$, $y_m$),  where x and y are the respective coordinates for each agent identified by the index of its coordinates on the row, and m being the number of agents. Followed by goals in the same format. Following are [makespan] lines each representing a single discrete timestep in the simulation, where each line has the coordinates of each agent in the above-mentioned format.

\secc{Map format}
Below is and example map file. This file file format is used both by the solver and visualizer to represent the environment. On the first line is the map type, represented by a string. Following are 2 lines representing the dimensions.
On the $5^{th}$ line, starts the actual map represented by [height] rows and [width] columns. Each grid tile is represented by single ASCII character. Currently, only 2 characters are differentiated. 
\begitems \style x
    * . - Representing blank space
    * T - Representing an obstacle
\enditems
\begtt
type octile
height 14
width 13
map
T....TTT....T
T...........T
.............
.............
.............
.............
.............
......T......
.............
.............
.............
.............
....T.T.T....
T..TTTTT....T
\endtt

\secc{General format expectations}
All positional data is assuming a grid representation of the simulated map. The representation of the data expects the coordinate (0, 0) to be the bottom-left corner of the simulation grid, while ($x_m - 1$, $y_m - 1$) is expected to be the top-right corner of the grid, where $x_m$, $y_m$ is the number of columns and rows in the simulation grid, respectively.

\label[mapfir_visualizer]
\sec The visualizer
The visualizer uses input file conforming to the format described in {~\ref[mapfir_solver_output_format]} to visualize the run of the generated simulation. It lets the user change the simulations speed and move through discrete time steps. Other features include selecting only single agent to display, stopping agent during the simulation and visual features such as hiding/showing of lines to goals.
\mapfirGui 

\sec Benefits 
The benefits of the format used by mapfIR are mainly
\begitems \style x
    * Human readability
    * Simple parsing
    * Ability to use community solvers
\enditems
Additionally, I believe that switching to a standardized IO format will enable more students to use the demonstrator, and eventually introduce new use-cases, that were not possible before due to the inaccessibility of the demonstrator. It might greatly increase the attractiveness of the field for students developing algorithms for path finding.