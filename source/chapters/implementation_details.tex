\chap Implementation
In this chapter I will describe my implementation and the particular solutions used to comply with decisions made in chapter ~\ref[chapter_implementation_decisions].

\sec Application architecture
The application is split between server part and frontend part.
Communicating through abstract interface built upon \nanomsg.

Both parts of application have shared utils classes. The main classes used for communication are Messenger (asynchronous handler for inbound/outbound messages) and Message (serializable container), providing easy-to-use interface and abstracting the network layer away from the programmer. The basic hierarchy of used communication classes is below.
\communicationUml
\break
Server and Frontend each have its own instance of Messenger associated with given Message type, communicating through api defined by given messenger. In the case of SynchronizedStateMessenger, the only the latest version of the synchronized state is publicly available to the user.

The asynchronous nature of the communication can be seen on the sequence diagram below.

\communicationSequence

The asynchronous handlers allow both applications to run in the main thread performing latency-sensitive tasks.

\sec GUI application
The GUI is implemented using {\of}. The GUI runs single thread for main logic and event handling, one for the GUI application, and one per each messenger, allowing uninterupted handling of all events that might arise and providing smooth rendering for the application



