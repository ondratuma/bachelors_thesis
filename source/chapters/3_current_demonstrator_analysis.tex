\chap Analysis of the SIPPDemonstrator project
In this chapter I will take a detailed look at the inner workings of SIPPDemonstrator project. The purpose of this chapter is also to point out differences in formats and inner workings that we need to migrate in order to achieve full copmatibility.

\sec Project history
The original project was developed as part of the {\safeLog} project, that aimed to study and enable the cooperation of people and robots in single robotized warehouse environment. Further work was done by Tomáš Rybecký as part of his  \tomasMThesis
\sec Input format
\secc Map file
The map file "Projekt_mapa4.xml" in the root of the directory was used as source for the navigation system on robots. The file is in xml format and consists of relatively simple definition of nodes, that are directly referred to by id from the qr codes placed on the laboratory floor. The rest of the map file was unused, but kept for possible backwards-compatibility. The rest of the file includes edges definition, describing the possible routes.
\br
\br
Example node
\begtt
<PickStationNode Id="464" X="3.5" Y="2.1">
\endtt
\vfil\break
\secc Execution plan
The execution plan was also supplied in the xml format, providing list of n points relative to the grid coordinates for each robot, with duration for each step. The coordinates were scaled relative to the grid coordinate system, and it was necessary to provide this scaling information at runtime for successful coordinate transformation. This information is however not encoded in the file itself.\br
Single robot execution plan can be seen on ~\ref[robot_execution_plan]
\robotExecutionPlan
\sec Components
The whole demonstration application consisted of 2 distinct parts communicating over TCP in the local network.
\secc Server
The server component was expected to be run at static IP address "192.168.2.4".This part of application was responsible for reading, parsing, converting the execution file into the grid coordinate system. Another of its responsibilities included handling connection from individual robots. Once connection to all robots have been established, the server would start sending individual commands to each robots, ensuring the order and timing of executed commands.
\secc Robots
The base of the software running on robots consists of ROS package, module responsible for navigation on the grid and simple communication layer executing commands received from the server. The robots were only responsible for executing the individual commands, and had no context of the whole simulation, or other robots.
\sec Runtime behavior
The runtime behavior is consistent and reliable in its main functionality, that is inherently limited by the purpose of the software.\br
Due to the multithreaded nature, the server was sometimes logging to stdout multiple logs at a time, resulting in message corruption, but that was a minor inconvenience, that did not affect the executed demonstration in any way.
\sec Server software analysis
The software structure was split into the server runner thread, and serializable classes representing the individual messages. Other utility classes for time synchronization were also used, although their impact was negligible. The communication with robots happened in a loop in the server thread.\br
During later stage, there were found some rather critical bugs in the NanoMsg abstraction used by both the server and client, that resulted in array out of bounds write and corruption of the stack, when the server IP address length increased. This, did not however affect the original project, as the server IP was static and relatively short.
\sec Robot software analysis
\secc Navigation
The navigation part proved to be well written and abstracted away the navigation problem completely. From the developer perspective, the whole abstraction usage can be simplified to two synchronous method calls 
\begitems \style x
    * "int driveToPosition(double x, double y, double time);"
    * "int turn (double angle);"
\enditems
The internal representation of the grid can be seen below on figure ~\ref[robot_grid]. All robot movement is calculated and realized relatively to this grid representation. The numbers on the individual grid tiles are embedded in the QR codes on the laboratory floor, and are the ids of the nodes in "Projekt_mapa4.xml" file. X represents missing node/obstacle.
\robotGrid
As additional safety measure, the underlying software abstracts away direct collision handling, during which the robots stops all further execution, to prevent any potential damage.

\secc Runner
The runner consisted of simple communication handler, calling the above mentioned navigation API, performing the desired tasks and returning the results. In case of not finishing the command, the robot would simply not send back the response, and the server would then reinitiate the command execution.
