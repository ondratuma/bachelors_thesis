\label[chap_3]
\chap Analysis of the SIPPDemonstrator project
In this chapter, I will take a detailed look at the inner workings of the SIPPDemonstrator project. The purpose of this chapter is also to point out differences in formats and inner workings that we need to migrate in order to achieve full compatibility.

\sec Project history
The original project was developed as part of the {\safeLog}, which aimed to study and enable the cooperation of people and robots in a single robotized warehouse environment. Further work was done by Tomáš Rybecký as part of his  thesis \cite[rybecky_2020]
\sec Input format
All data-related input and output files used in the original project are XML-based. The XML format has numerous advantages for advanced use-cases that need more metadata, but at the same time, it is hard to read by human operators and its parsing, as currently implemented, is overly complicated.
\secc Map file
The map file "Projekt_mapa4.xml" in the root of the directory was used as the source for the navigation system on robots. The file is in XML format and consists of a relatively simple definition of nodes that are directly referred to by id from the bar codes placed on the laboratory floor. The rest of the map file was unused but kept for possible backward compatibility. It includes edges definition, describing the possible routes.

\label[fc_coordinate_system]
\secc{Coordinate system convention}
The coordinate system representation in the file is independent of the rotation of the whole coordinate system. It is, by convention, expected to begin in the lower-left corner of the imaginary grid, growing linearly to the upper right corner of the grid. The rotation of the coordinate system plays a role only in the physical robots; therefore, keeping the convention standardized across both components simplifies the potential visualization of the plans and makes it simpler to imagine the final plan without the need to perform multi-dimensional rotations. This is in contrast to the coordinate system used by {\mapfIR} described in {~\ref[mapfir_coordinate_system]}, which begins in the upper left corner.

\br
\br
Example node
\begtt
<PickStationNode Id="464" X="3.5" Y="2.1">
\endtt
\vfil\break
\secc Execution plan
The execution plan was also supplied in the XML format, providing a list of n points relative to the grid coordinates for each robot, with duration for each step. The coordinates were scaled relative to the grid coordinate system, and it was necessary to provide this scaling information at runtime for successful coordinate transformation. This information is, however, not encoded in the file itself.\br
I'd also like to point out that, in contrast to the solution generated by {\mapfIR}, this execution plan does not use discreet time steps to synchronize the whole simulation. It uses the timing information provided in each command definition to avoid collisions and ensure synchronization across commands.
A single robot execution plan can be seen on ~\ref[robot_execution_plan]
\robotExecutionPlan
\sec Components
The whole demonstration application consisted of 2 distinct parts communicating over TCP in the local network.\br
Custom layer built upon the nanomsg library serves as the common facilitator for all network communication across all components. It simplifies the interface provided by the library and provides unified access to the network layer. Nanomsg is a socket library that provides several common communication patterns. It aims to make the networking layer fast, scalable, and easy to use. It is implemented in C. \cite[nanomsg]

\secc Server
The server component was expected to be run at static IP address "192.168.2.4".This part of the application was responsible for reading, parsing, and converting the execution file into the grid coordinate system used by robots. Another of its responsibilities included handling the connections from individual robots. Once all connections have been established, the server would start sending individual commands to each robot, ensuring the order and timing of the executed commands.
\secc Robots
The robot model used is TurtleBot 2. {\uv {TurtleBot is a low-cost, personal robot kit with open-source software.}}\cite[turtlebot]. {\uv {The TurtleBot kit consists of a mobile base, 2D/3D distance sensor, laptop computer or SBC(Single Board Computer), and the TurtleBot mounting hardware kit.}}\cite[turtlebot]
The robot is equipped with a Kinect sensor on the front, as can be seen in Figure {\ref[robot_front]}. Vicon markers are glued to the top of the robot in a predefined constellation, as can be seen in Figure {\ref[robot_top]}. Each robot is mapped to name in the Vicon system based on the tag constellation. The complete fleet used during the demonstration can be seen on Figure {\ref[robot_fleet]} together with the bar codes used for their navigation.

\midinsert
\line{\hsize=.5\hsize \vtop{%
        \clabel[robot_front]{Robot front}
        \picw=4.7cm \cinspic {../assets/images/robot_front.png}
        \caption/f Robot front view
   \par}\vtop{%
        \clabel[robot_rear]{Robot rear}
        \picw=4.7cm \cinspic {../assets/images/robot_rear.png}
        \caption/f Robot rear view
   \par}}
\endinsert

\midinsert
    \clabel[robot_fleet]{Robot fleet}
    \picw=12cm \cinspic {../assets/images/robot_fleet.png}
    \caption/f Robot fleet
\endinsert

\midinsert
    \clabel[robot_top]{Robot top}
    \picw=4.7cm \cinspic {../assets/images/robot_top.png}
    \caption/f Robot top view
\endinsert

The robot is running the Robot Operating System (ROS). ROS {\uv { is a set of software libraries and tools that help you build robot applications. From drivers to state-of-the-art algorithms, and with powerful developer tools, ROS has what you need for your next robotics project. And it's all open source.}}\cite[ros_website] The base of the software running on robots consists of a ROS package, a module responsible for navigation on the grid, and a simple communication layer executing the commands received from the server. This layer will be referred to as "runner" in the rest of this thesis. The robots were only responsible for executing the individual commands and had no context of the whole simulation or other robots.

\sec Environment

\sec Server software analysis
The software structure was split into the server runner thread and serializable classes representing the individual messages. Other utility classes for time synchronization were also used, although their impact was negligible. The communication with robots happened in a loop in the server thread.\br
During a later stage, there were found some rather critical bugs in the nanomsg abstraction used by both the server and client that resulted in an array out of bounds write and corruption of the stack when the server's IP address length increased. This did not, however, affect the original project, as the server IP was static and relatively short.
\sec Robot software analysis
\label[position_api]
\secc Navigation
The navigation part proved to be well written and abstracted away the navigation problem completely. From the developer's perspective, the whole abstraction usage can be simplified to two synchronous method calls 
\begitems \style x
    * "int driveToPosition(double x, double y, double time);"
    * "int turn (double angle);"
\enditems
The underlying solution for the navigation system is based on the AprilTag project. It {\uv {is a visual fiducial system, useful for a wide variety of tasks including augmented reality, robotics, and camera calibration. Targets can be created from an ordinary printer, and the AprilTag detection software computes the precise 3D position, orientation, and identity of the tags relative to the camera. The AprilTag library is implemented in C with no external dependencies. It is designed to be easily included in other applications, as well as be portable to embedded devices.}}\cite[apriltag]

The internal representation of the grid can be seen below in Figure ~\ref[robot_grid]. All robot movement is calculated and realized relatively to this grid representation. The numbers on the individual grid tiles are embedded in the bar codes on the laboratory floor and are the ids of the nodes in the "Projekt_mapa4.xml" file. X represents a missing node/obstacle.
\robotGrid
As an additional safety measure, the underlying software abstracts away direct collision handling, during which the robot stops all further execution to prevent any potential damage.

\secc Runner
The runner consisted of a simple communication handler, calling the above-mentioned navigation API, performing the desired tasks, and returning the results. In case of not finishing the command, the robot would simply not send back the response, and the server would then reinitiate the command execution.

\sec Runtime behavior
The runtime behavior is consistent and reliable in its main functionality, which is inherently limited by the purpose of the software.\br
Due to the multithreaded nature, the server was sometimes logging to stdout multiple logs at a time, resulting in message corruption, but that was a minor inconvenience, that did not affect the executed demonstration in any way.
