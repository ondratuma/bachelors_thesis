\chap Analysis of the SIPPDemonstrator project
In this chapter, I will take a detailed look at the inner workings of the SIPPDemonstrator project. The purpose of this chapter is also to point out differences in formats and inner workings that we need to migrate in order to achieve full compatibility.

\sec Project history
The original project was developed as part of the {\safeLog} project, that aimed to study and enable the cooperation of people and robots in a single robotized warehouse environment. Further work was done by Tomáš Rybecký as part of his  \tomasMThesis
\sec Input format
All data-related input and output files used in the original project are XML-based. The XML format has numerous advantages for advanced use-cases, that need more metadata, but at the same time is hard to read by human operators and its parsing, as currently implemented, is overly complicated.
\secc Map file
The map file "Projekt_mapa4.xml" in the root of the directory was used as the source for the navigation system on robots. The file is in XML format and consists of a relatively simple definition of nodes, that are directly referred to by id from the QR codes placed on the laboratory floor. The rest of the map file was unused but kept for possible backward compatibility. The rest of the file includes edges definition, describing the possible routes.

\label[fc_coordinate_system]
\secc{Coordinate system convention}
The coordinate system representation in the file is independent of the rotation of the whole coordinate system. It is, by convention, expected to begin in the lower-left corner of the imaginary grid, growing linearly to the upper right corner of the grid. The rotation of the coordinate system plays a role only in the physical robots, therefore keeping the convention common across both components simplifies the potential visualization of the plans, and makes it simpler to imagine the final plan without the need to perform multi-dimensional rotations. This is in contrast to the coordinate system used by {\mapfIR} described in {~\ref[mapfir_coordinate_system]}, which begins in the upper left corner.

\br
\br
Example node
\begtt
<PickStationNode Id="464" X="3.5" Y="2.1">
\endtt
\vfil\break
\secc Execution plan
The execution plan was also supplied in the XML format, providing a list of n points relative to the grid coordinates for each robot, with duration for each step. The coordinates were scaled relative to the grid coordinate system, and it was necessary to provide this scaling information at runtime for successful coordinate transformation. This information is however not encoded in the file itself.\br
I'd also like to point out, that in contrast to the solution generated by {\mapfIR}, this execution plan does not use discreet time steps to synchronize the whole simulation. It uses the timing information provided in each command definition to avoid collisions and ensure synchronization across commands.
A single robot execution plan can be seen on ~\ref[robot_execution_plan]
\robotExecutionPlan
\sec Components
The whole demonstration application consisted of 2 distinct parts communicating over TCP in the local network.
\secc Server
The server component was expected to be run at static IP address "192.168.2.4".This part of the application was responsible for reading, parsing, and converting the execution file into the grid coordinate system used by robots. Another of its responsibilities included handling the connections from individual robots. Once all connections have been established, the server would start sending individual commands to each robot, ensuring the order and timing of the executed commands.
\secc Robots
The base of the software running on robots consists of a ROS package, a module responsible for navigation on the grid, and a simple communication layer executing the commands received from the server. The robots were only responsible for executing the individual commands and had no context of the whole simulation, or other robots.
\sec Server software analysis
The software structure was split into the server runner thread, and serializable classes representing the individual messages. Other utility classes for time synchronization were also used, although their impact was negligible. The communication with robots happened in a loop in the server thread.\br
During later stage, there were found some rather critical bugs in the NanoMsg abstraction used by both the server and client, that resulted in array out of bounds write and corruption of the stack, when the server IP address length increased. This, did not however affect the original project, as the server IP was static and relatively short.
\sec Robot software analysis
\label[position_api]
\secc Navigation
The navigation part proved to be well written and abstracted away the navigation problem completely. From the developer perspective, the whole abstraction usage can be simplified to two synchronous method calls 
\begitems \style x
    * "int driveToPosition(double x, double y, double time);"
    * "int turn (double angle);"
\enditems
The internal representation of the grid can be seen below on figure ~\ref[robot_grid]. All robot movement is calculated and realized relatively to this grid representation. The numbers on the individual grid tiles are embedded in the QR codes on the laboratory floor, and are the ids of the nodes in "Projekt_mapa4.xml" file. X represents missing node/obstacle.
\robotGrid
As additional safety measure, the underlying software abstracts away direct collision handling, during which the robots stops all further execution, to prevent any potential damage.

\secc Runner
The runner consisted of simple communication handler, calling the above mentioned navigation API, performing the desired tasks and returning the results. In case of not finishing the command, the robot would simply not send back the response, and the server would then reinitiate the command execution.

\sec Runtime behavior
The runtime behavior is consistent and reliable in its main functionality, that is inherently limited by the purpose of the software.\br
Due to the multithreaded nature, the server was sometimes logging to stdout multiple logs at a time, resulting in message corruption, but that was a minor inconvenience, that did not affect the executed demonstration in any way.
