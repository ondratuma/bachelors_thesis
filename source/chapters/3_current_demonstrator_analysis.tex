\chap Analysis of the SIPPDemonstrator project
In this chapter I will take a detailed look at the inner workings of SIPPDemonstrator project. The purpose of this chapter is also to point out differences in formats and inner workings that we need to migrate in order to achieve full copmatibility.

\sec Project history
The original project was developed as part of the {\safeLog} project, that aimed to study and enable the cooperation of people and robots in single robotized warehouse environment. Further work was done by Tomáš Rybecký as part of his  \tomasMThesis
\sec Input format
\secc Map file
The map file "Projekt_mapa4.xml" in the root of the directory was used as source for the navigation system on robots. The file is in xml format and consists of relatively simple definition of nodes, that are directly referred to by id from the qr codes placed on the laboratory floor. The rest of the map file was unused, but kept for possible backwards-compatibility. The rest of the file includes edges definition, describing the possible routes.
\br
\br
Example node
\begtt
<PickStationNode Id="464" X="3.5" Y="2.1">
\endtt
\secc Execution plan
The execution plan was also supplied in the xml format, providing list of n points relative to the grid coordinates for each robot, with duration for each step. The coordinates were scaled relative to the grid coordinate system, and it was necessary to provide this scaling information at runtime for successful coordinate transformation. This information is however not encoded in the file itself.\br
Single robot execution plan could look like this
\begtt
<agent id="5" start.x="37" start.y="37" start.heading="180" goal.x="39" goal.y="11" goal.heading="90" size="0.40000001" movespeed="0.25" rotationspeed="0.2">
            <path pathfound="true" runtime="0.0026935136" duration="119.83047">
                <section id="0" start.x="37" start.y="37" start.heading="180" goal.x="37" goal.y="37" goal.heading="99.462318" duration="2.2371578"/>
                <section id="1" start.x="37" start.y="37" start.heading="99.462318" goal.x="36" goal.y="31" goal.heading="99.462318" duration="24.331051"/>
                <section id="2" start.x="36" start.y="31" start.heading="99.462318" goal.x="36" goal.y="31" goal.heading="97.594643" duration="0.051879968"/>
                <section id="3" start.x="36" start.y="31" start.heading="97.594643" goal.x="34" goal.y="16" goal.heading="97.594643" duration="60.530983"/>
                <section id="4" start.x="34" start.y="16" start.heading="97.594643" goal.x="34" goal.y="16" goal.heading="53.130104" duration="1.2351261"/>
                <section id="5" start.x="34" start.y="16" start.heading="53.130104" goal.x="37" goal.y="12" goal.heading="53.130104" duration="20"/>
                <section id="6" start.x="37" start.y="12" start.heading="53.130104" goal.x="37" goal.y="12" goal.heading="26.565052" duration="0.73791808"/>
                <section id="7" start.x="37" start.y="12" start.heading="26.565052" goal.x="39" goal.y="11" goal.heading="26.565052" duration="8.944272"/>
                <section id="8" start.x="39" start.y="11" start.heading="26.565052" goal.x="39" goal.y="11" goal.heading="90" duration="1.7620819"/>
            </path>
        </agent>
\endtt
\sec Components
The whole demonstration application consisted of 2 distinct parts communicating over TCP in the local network.
\secc Server
The server component was expected to be run at static IP address "192.168.2.4".This part of application was responsible for reading, parsing, converting the execution file into the grid coordinate system. Another of its responsibilities included handling connection from individual robots. Once connection to all robots have been established, the server would start sending individual commands to each robots, ensuring the order and timing of executed commands.
\secc Robots
The base of the software running on robots consists of ROS package, module responsible for navigation on the grid and simple communication layer executing commands received from the server.
The internal representation of the grid can be seen below on figure ~\ref[robot_grid]. All robot movement is calculated and realized relatively to this grid representation. The numbers on the individual grid tiles are embedded in the QR codes on the laboratory floor, and are the ids of the nodes in "Projekt_mapa4.xml" file. X represents missing node/obstacle.
\robotGrid
\sec Runtime behavior
The runtime behavior is consistent and reliable in its main functionality, that is inherently limited by the purpose of the software.
\sec Server software analysis
The software structure was split into the server runner thread, and serializable classes representing the individual messages. Other utility classes for time synchronization were also used, although their impact was negligible.
\sec Robot software analysis
\secc Navigation
The navigation part proved to be well written and abstracted away the navigation problem completely. From the developer perspective, the whole abstraction usage can be simplified to two synchronous method calls 
\begitems \style x
    * "int driveToPosition(double x, double y, double time);"
    * "int turn (double angle);"
\enditems
The underlying software abstracts away direct collision handling, during which the robots stops all further execution, to prevent any potential damage.

\secc Runner
The runner consisted of simple communication handler, calling the above mentioned navigation API, performing the desired tasks and returning the results.
